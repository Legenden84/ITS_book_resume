## 6.8 ‡Background: Process Creation, Syscalls, Shells, Shellcode

### Shellcode (Terminology)
Shellcode is a critical concept in understanding security exploits, referring specifically to a sequence of injected code meant to be executed by a compromised system. Traditionally, shellcode is used to open a command shell for the attacker, providing them with a wide range of capabilities to interact with the system, manipulate files, and execute arbitrary commands. The ultimate goal for many attackers is to escalate their privileges to obtain a root shell, giving them unrestricted access to the system. Shellcode, in its broader application, is not limited to just spawning command shells but includes any code that fulfills a particular attack objective. This could involve transferring control to a more extensive set of malicious instructions or launching additional executable payloads to deepen the intrusion.

### Syscalls and C Library (Background)
Understanding shellcode and system exploitation requires a solid grasp of syscalls (system calls) and their role in system operations. Syscalls serve as the gateway for user space programs to request services and interact with the kernel, handling low-level operations like file I/O. These calls are OS and hardware-specific, and they are commonly accessed via the C standard library (libc), which provides a user-friendly wrapper around these syscalls. The libc functions handle the nitty-gritty details, preparing the system for the syscall, which includes loading parameters into registers according to the platform's calling conventions and triggering a context switch to supervisor mode via a TRAP or software interrupt. Running in supervisor mode is necessary for syscalls as they require access to protected kernel resources. It is important to distinguish between supervisor mode, a CPU hardware privilege level, and superuser (root) processes, which operate in user space but have elevated privileges within the OS.

### Command Shells and Fork (Background)
Command shells play a pivotal role in interfacing with the operating system, providing a user-friendly means to issue commands and interact with the system. While graphical user interfaces (GUIs) offer an alternative, command shells remain a mainstay, especially for power users and administrators. In Unix systems, a user’s interaction with the shell begins upon login, with the OS initializing a shell process in user space. The shell waits for user input, interpreting commands, and creating child processes to execute them. This is achieved using the `fork()` syscall, which duplicates the current process, and the `execve()` syscall, which replaces the current process image with the desired program. The shell then waits for the child process to complete before returning control to the user. If a command is issued with an ampersand "&", the shell runs the command in the background, allowing for concurrent execution. This functionality is not unique to Unix, with analogous shells existing in other operating systems, such as "cmd.exe" in Windows.

### Execve Shell (Background)
The `execve()` syscall is a cornerstone for process creation, allowing for the execution of a specified executable, replacing the current process image. It requires three arguments: the file path of the executable, an argument vector, and an array of environment variables. The function is versatile, supporting both binary executables and scripts, with the filename determining the execution context. The `execve()` function represents a family of exec syscalls, with variations like `execl()` providing alternative ways to specify arguments. The ability to compile C code into a short machine code sequence makes it an attractive vector for attackers, who can inject shellcode to create a shell with minimal effort.

### Shellcode: Technical Challenges
Despite its effectiveness, shellcode injection is not without its technical hurdles. Two primary challenges are the elimination of NUL bytes, which can prematurely terminate string processing routines, and the need for relative addressing to ensure position-independent code. The unpredictability of where the shellcode will reside in memory necessitates the use of relative addressing, either through PC-relative addressing or register-relative addressing, depending on the architecture. While these challenges may seem daunting, the security community has documented them extensively, and automated tools are readily available to generate functional shellcode, lowering the barrier to entry for attackers.
