# 6.4 Heap-based Buffer Overflows and Heap Spraying

Heap-based buffer overflows can affect buffers located in the heap memory and the data segment, which can be divided into read-only and read-write areas. These sections of memory are crucial because, traditionally, they have been left writable and executable, which is unnecessary and poses a security risk. Static buffers can be declared in BSS, like so: `static int bufferX[4];`.

## Overflowing higher-address variables
The approach to exploiting heap-based buffers differs from stack-based due to the variability of dynamic memory allocation across systems. Attackers need to map out the memory to identify a vulnerable buffer and a strategically valuable higher-address variable that can be tampered with. Successful exploitation hinges on the attacker's ability to corrupt memory values without crashing the program. For example, a variable that controls access permissions could be flipped from `FALSE` to `TRUE`, or a function pointer could be overwritten to redirect control flow to attacker-chosen code.

## Type of state corrupted
Understanding the exploit involves considering the types of corrupted variables which may include:

- Stack-based pointers such as return addresses and frame pointers.
- Function pointers located in the stack, heap, or static area, including those in address lookup tables like vtables.
- Addresses involved in `setjmp`/`longjmp` functions used for non-standard call sequences.
- Data involved in branch tests, leading to a fixed address after the branch.

## Generic exploit steps
The exploitation process typically unfolds in three steps:

1. **Code Injection or Location**: Attacker’s code is placed within the target’s address space. If existing code can be used, only its address is needed.
2. **Corruption of Control Flow Data**: Key data structures are overwritten, setting up a control transfer to the injected or identified code.
3. **Seizure of Control**: Control is transferred to the chosen code.

## Heap spraying
Heap spraying populates the heap with many instances of the code that the attacker intends to execute, effectively completing step 1 of the exploit process. For example, a web page might run a script embedding 10,000 strings in a loop, with each string containing a no-op sled and shellcode. This could also be done by causing the rendering of a web page to load an image that results in similar heap allocations. For step 2, any method may be employed to shift program control to the heap. The aim is to increase the chances of a random transfer to the heap, landing on a no-op sled and subsequently executing the shellcode. This method often employs JavaScript, a type-safe language, and can bypass defenses like heap layout randomization.
